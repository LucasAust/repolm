{
  "slug": "react",
  "repo": "facebook/react",
  "name": "React",
  "description": "The library that revolutionized UI development. Learn the virtual DOM, reconciliation, and hooks.",
  "tags": [
    "JavaScript",
    "UI Library",
    "Frontend"
  ],
  "depth": "high-level",
  "expertise": "amateur",
  "overview": "Let's explore React, the JavaScript library that fundamentally changed how we build user interfaces.\n\n### 1. The Big Picture: A Declarative UI Library\n\nReact, maintained by Meta, is not a full framework \u2014 it's a library focused on one thing: building user interfaces through composable components. Its tagline, \"A JavaScript library for building user interfaces,\" undersells just how revolutionary its approach has been.\n\nThe key insight behind React is **declarative rendering**. Instead of imperatively manipulating the DOM (\"find this element, change its text, add this class\"), you describe *what* the UI should look like for a given state, and React figures out how to make it happen.\n\n```jsx\n// Declarative: describe the result\nfunction Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}\n\n// vs Imperative: describe the steps\ndocument.getElementById('greeting').textContent = 'Hello, ' + name;\n```\n\nThis shift from \"how\" to \"what\" is the foundation of everything React does.\n\n### 2. Components: The Building Blocks\n\nReact applications are built from **components** \u2014 self-contained pieces of UI that manage their own rendering logic. Components can be as simple as a button or as complex as an entire page.\n\n```jsx\nfunction UserCard({ user }) {\n  return (\n    <div className=\"card\">\n      <img src={user.avatar} alt={user.name} />\n      <h2>{user.name}</h2>\n      <p>{user.bio}</p>\n    </div>\n  );\n}\n```\n\nComponents compose naturally \u2014 you build complex UIs by nesting simple components:\n\n```jsx\nfunction UserList({ users }) {\n  return (\n    <div>\n      {users.map(user => <UserCard key={user.id} user={user} />)}\n    </div>\n  );\n}\n```\n\nThis composability is React's superpower. Each component is a reusable, testable unit of UI.\n\n### 3. JSX: JavaScript + HTML\n\nReact introduced **JSX**, a syntax extension that lets you write HTML-like code inside JavaScript. It looks like HTML but compiles down to regular JavaScript function calls:\n\n```jsx\n// What you write\nconst element = <h1 className=\"title\">Hello</h1>;\n\n// What it compiles to\nconst element = React.createElement('h1', { className: 'title' }, 'Hello');\n```\n\nJSX isn't required \u2014 you could write `React.createElement` calls manually \u2014 but it makes component code dramatically more readable. It's one of React's most controversial and most loved features.\n\n### 4. The Virtual DOM and Reconciliation\n\nThis is the engineering heart of React. When state changes in your application, React doesn't immediately update the real DOM (which is slow). Instead, it:\n\n1. **Renders** a new virtual DOM tree \u2014 a lightweight JavaScript representation of the UI\n2. **Diffs** it against the previous virtual DOM tree (this is called \"reconciliation\")\n3. **Commits** only the minimal set of changes to the real DOM\n\nThe reconciliation algorithm, found in `packages/react-reconciler/`, is sophisticated. It uses several heuristics to make diffing fast:\n\n- **Different element types** produce different trees (skip diffing children)\n- **Keys** help React identify which items in a list changed, moved, or were removed\n- **Fiber architecture** breaks rendering work into chunks that can be paused and resumed\n\nThis is why React can handle complex, frequently-updating UIs without becoming sluggish.\n\n### 5. The Fiber Architecture\n\nReact 16 introduced **Fiber**, a complete rewrite of the reconciliation engine. The old \"stack reconciler\" processed updates synchronously \u2014 once it started rendering, it couldn't stop until the entire tree was processed. This caused jank on complex updates.\n\nFiber changes this fundamentally. Each component instance becomes a \"fiber\" \u2014 a JavaScript object that represents a unit of work. The Fiber reconciler can:\n\n- **Pause** work and come back to it later\n- **Assign priority** to different types of updates\n- **Reuse** previously completed work\n- **Abort** work if it's no longer needed\n\nThis is the foundation for React's concurrent features. A user typing in an input (high priority) won't be blocked by a large list re-rendering (low priority).\n\nThe key files are in `packages/react-reconciler/src/`:\n- `ReactFiber.js` \u2014 The fiber node data structure\n- `ReactFiberWorkLoop.js` \u2014 The main work loop that processes fibers\n- `ReactFiberBeginWork.js` \u2014 Starts processing a fiber (renders component)\n- `ReactFiberCompleteWork.js` \u2014 Completes a fiber (creates DOM nodes)\n\n### 6. Hooks: Function Components Supercharged\n\nBefore hooks (React 16.8), you needed class components for state and lifecycle methods. Hooks changed everything by letting function components do everything classes could \u2014 and more.\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  useEffect(() => {\n    document.title = `Count: ${count}`;\n  }, [count]);\n  \n  return (\n    <button onClick={() => setCount(count + 1)}>\n      Clicked {count} times\n    </button>\n  );\n}\n```\n\nThe core hooks:\n- **useState** \u2014 Local state management\n- **useEffect** \u2014 Side effects (data fetching, subscriptions, DOM manipulation)\n- **useContext** \u2014 Access context values without nesting\n- **useRef** \u2014 Mutable references that persist across renders\n- **useMemo / useCallback** \u2014 Performance optimization through memoization\n- **useReducer** \u2014 Complex state logic with reducer pattern\n\nHooks are implemented in `packages/react-reconciler/src/ReactFiberHooks.js` \u2014 they work by maintaining a linked list of hook states attached to each fiber.\n\n### 7. The Renderer Architecture\n\nOne of React's most elegant architectural decisions is the separation between the **reconciler** (which manages the component tree and diffing) and **renderers** (which actually create platform-specific UI).\n\nThis is why React can target multiple platforms:\n- **react-dom** \u2014 Renders to the browser DOM\n- **react-native** \u2014 Renders to iOS/Android native views\n- **react-three-fiber** \u2014 Renders to WebGL/Three.js\n- **react-pdf** \u2014 Renders to PDF documents\n- **Ink** \u2014 Renders to the terminal\n\nThe reconciler doesn't know or care about the target platform. It just calls methods on a \"host config\" that each renderer provides. This is defined in `packages/react-reconciler/src/ReactFiberConfig.js`.\n\n### 8. Concurrent React and Suspense\n\nReact's latest major features build on the Fiber architecture:\n\n**Concurrent Rendering** allows React to prepare multiple versions of the UI at the same time. It can start rendering an update, pause to handle a more urgent update, and then resume \u2014 all without blocking the main thread.\n\n**Suspense** lets components \"suspend\" rendering while waiting for async data:\n\n```jsx\nfunction ProfilePage() {\n  return (\n    <Suspense fallback={<Spinner />}>\n      <ProfileDetails />\n      <Suspense fallback={<PostsSkeleton />}>\n        <ProfilePosts />\n      </Suspense>\n    </Suspense>\n  );\n}\n```\n\nThis declarative approach to loading states is far cleaner than manually tracking `isLoading` booleans.\n\n### 9. Server Components\n\nThe latest evolution: React Server Components (RSC) allow components to run on the server and send their rendered output to the client. Server components can:\n\n- Access databases and file systems directly\n- Keep large dependencies server-side (zero bundle size impact)\n- Stream HTML to the client progressively\n\n```jsx\n// This component runs on the server\nasync function BlogPost({ id }) {\n  const post = await db.posts.findById(id);  // Direct DB access!\n  return <article>{post.content}</article>;\n}\n```\n\nThis blurs the line between server and client in a way that feels natural within React's component model.\n\n### Summary\n\nReact's architecture is built on a few key principles:\n\n- **Declarative over imperative** \u2014 Describe what, not how\n- **Components as the unit of abstraction** \u2014 Everything is a composable component\n- **Virtual DOM + Reconciliation** \u2014 Efficient updates through intelligent diffing\n- **Fiber architecture** \u2014 Interruptible, prioritized rendering\n- **Platform-agnostic core** \u2014 The reconciler is separate from renderers\n- **Progressive complexity** \u2014 Start simple with components and hooks, scale to concurrent features and server components\n\nReact didn't just create a library \u2014 it created a mental model for thinking about UIs that has influenced virtually every frontend framework that followed.",
  "podcast": "*(Intro music fades in \u2014 upbeat, modern electronic)*\n\nALEX: Welcome back to RepoLM! I'm Alex, and today we're tackling what might be the single most influential piece of frontend code ever written.\n\nSAM: I'm Sam, and yeah \u2014 we're talking about React. The `facebook/react` repository. Over 230,000 stars on GitHub, powering everything from Facebook to Netflix to the New York Times. If you've used the web in the last decade, you've interacted with React.\n\nALEX: It's massive. And I have to say, when I first cloned the repo and looked at the directory structure, I was a bit overwhelmed. There's a `packages` directory with like 30+ sub-packages. Where do we even begin?\n\nSAM: Let's start with the \"why\" before the \"how.\" React exists because of a fundamental problem: building complex, interactive UIs is really, really hard. Before React, the dominant pattern was imperative DOM manipulation \u2014 you'd listen for events, find elements, update them manually. jQuery made this easier, but it didn't solve the fundamental complexity problem.\n\nALEX: Right \u2014 as your app grew, keeping the DOM in sync with your data became a nightmare of spaghetti event handlers.\n\nSAM: Exactly. React's revolutionary insight was: what if you just *described* what the UI should look like for a given state, and let the library figure out how to update the DOM efficiently? That's the declarative model.\n\nALEX: \"Tell me what you want, not how to get there.\"\n\nSAM: Perfect. And to make that efficient \u2014 because you can't just re-render the entire page on every state change \u2014 they invented the virtual DOM and the reconciliation algorithm.\n\nALEX: The famous \"virtual DOM diff.\" Let's talk about that. I found the reconciler code in `packages/react-reconciler/`. It's the biggest package in the entire repo.\n\nSAM: And for good reason \u2014 it's the brain of React. Here's how it works conceptually. When your component's state changes, React calls your component function again. That produces a new tree of React elements \u2014 that's the virtual DOM. React then compares this new tree to the previous one and computes the minimum set of changes needed to update the real DOM.\n\nALEX: So instead of \"change this div's text, add this class, remove that element,\" React does a diff and batches only the necessary mutations?\n\nSAM: Precisely. And the algorithm is clever about it. It uses heuristics \u2014 if two elements have different types, don't bother diffing their children, just replace the whole subtree. If list items have `key` props, use those to match items efficiently instead of re-rendering the whole list.\n\nALEX: That's why the React docs are so insistent about using proper keys in lists!\n\nSAM: Yes! Without keys, React falls back to index-based matching, which can cause bugs with stateful components in lists. The keys let the reconciler say \"ah, this item with key 'user-42' moved from position 3 to position 1, I'll just move the DOM node.\"\n\nALEX: Fascinating. Now, you mentioned the reconciler is the biggest package. But I noticed something interesting \u2014 it's separate from `react-dom`. Why is the reconciler its own package?\n\nSAM: This is one of the most elegant architectural decisions in the whole project. React separates *what* to render from *where* to render it. The reconciler handles the component tree, diffing, hooks, state management \u2014 all the core logic. But it doesn't know anything about the DOM.\n\nALEX: So who handles the DOM?\n\nSAM: The renderer. `react-dom` is one renderer. `react-native` is another. `react-three-fiber` renders to WebGL. There's even a renderer called Ink that renders React components to the terminal! The reconciler just calls abstract methods like \"create instance,\" \"append child,\" \"update text content.\" Each renderer implements these for its target platform.\n\nALEX: That's why React can run everywhere. The core logic is platform-agnostic.\n\nSAM: Exactly. It's a beautiful example of the dependency inversion principle. The high-level module (reconciler) doesn't depend on low-level modules (DOM APIs). Both depend on an abstraction (the host config interface).\n\nALEX: OK, let's talk about the elephant in the room \u2014 or should I say the fiber in the room. React 16 introduced Fiber, which was a complete rewrite of the reconciliation engine. What problem did it solve?\n\nSAM: The old reconciler \u2014 called the \"stack reconciler\" \u2014 had a major limitation: once it started processing an update, it couldn't stop. If you had a huge component tree, rendering it would block the main thread. The browser couldn't handle user input, animations would jank, everything would freeze.\n\nALEX: The dreaded \"React is slow\" complaint from the pre-Fiber era.\n\nSAM: Right. Fiber fixed this by making rendering *interruptible*. Instead of recursively processing the entire tree in one go, each component becomes a \"fiber\" \u2014 a unit of work. The scheduler can process a few fibers, pause to let the browser handle a paint or an input event, and then resume.\n\nALEX: So it's like cooperative multitasking for rendering.\n\nSAM: Great analogy! And it goes further \u2014 different updates get different priorities. A user typing in an input is high priority. A large list re-rendering in the background is low priority. React can interrupt the low-priority work to handle the high-priority update instantly.\n\nALEX: That's what \"concurrent mode\" or \"concurrent features\" is all about?\n\nSAM: Yes. Concurrent React is the culmination of the Fiber architecture. It enables things like `useTransition` \u2014 \"start this update, but if something more urgent comes in, handle that first.\" And `Suspense`, which lets components pause rendering while waiting for data.\n\nALEX: Suspense is so cool. Instead of manually managing loading states with `isLoading` booleans, you just... throw a promise and React catches it.\n\nSAM: (Laughs) Well, not exactly \"throw a promise,\" but that's the mental model! A component can signal \"I'm not ready yet,\" and the nearest `Suspense` boundary will show a fallback. When the data arrives, React re-renders seamlessly. It's declarative loading states.\n\nALEX: Let's shift to hooks, because that's what most developers interact with daily. I found the implementation in `ReactFiberHooks.js` \u2014 it's a big file.\n\nSAM: It's a fascinating file. Hooks seem magical from the outside \u2014 how does `useState` know which component it belongs to? How does it persist state across re-renders? The answer is elegant: each fiber has a linked list of hooks. When React renders your component, it walks through this linked list in order.\n\nALEX: That's why hooks can't be called conditionally!\n\nSAM: Exactly. If you put a `useState` inside an `if` block, the linked list gets out of order on the next render. React relies on the order of hook calls being consistent. It's a constraint, but it makes the implementation simple and fast.\n\nALEX: There's also `useEffect`, which replaces lifecycle methods. How does that fit in?\n\nSAM: Effects are collected during rendering but *executed* after the DOM has been updated. React queues them up and flushes them asynchronously. The dependency array tells React whether to re-run the effect \u2014 if the deps haven't changed, skip it. This is way more granular than class lifecycle methods, where `componentDidUpdate` fired for *any* state change.\n\nALEX: OK, I want to touch on one more thing \u2014 Server Components. It's the newest major feature. What's the deal?\n\nSAM: Server Components are React's answer to a question the community has been grappling with: how do you combine the composability of React with the performance benefits of server rendering? With Server Components, some components in your tree run *only on the server*. They can access databases directly, use Node.js APIs, and their code never ships to the client.\n\nALEX: Zero bundle size for server components.\n\nSAM: Zero. And they can pass their rendered output to client components seamlessly. The mental model is: your component tree is one unified thing, but some branches run on the server and some on the client. React handles the boundary.\n\nALEX: It's wild how React keeps evolving. From class components to hooks, from synchronous rendering to concurrent features, from client-only to server components.\n\nSAM: And that's what makes the repository so fascinating to study. You can see the layers of evolution in the code. The Fiber architecture was designed with concurrent rendering in mind years before it shipped. The renderer abstraction was there from the start, enabling React Native and beyond.\n\nALEX: It's like they were playing chess while everyone else was playing checkers.\n\nSAM: (Laughs) That's a bit generous, but there was definitely a long-term vision. The React team has always been willing to do massive internal rewrites \u2014 like Fiber \u2014 without breaking the public API. That commitment to backwards compatibility while innovating internally is rare and admirable.\n\nALEX: So to wrap up \u2014 if someone's diving into the React repo for the first time, where should they start?\n\nSAM: Start with `packages/react/`. That's the public API \u2014 `createElement`, `useState`, `useEffect`. It's surprisingly thin. Then look at `packages/react-reconciler/` \u2014 specifically `ReactFiberWorkLoop.js` to understand the rendering loop, and `ReactFiberHooks.js` to understand hooks. Finally, look at `packages/react-dom/` to see how the reconciler's abstract operations map to actual DOM mutations.\n\nALEX: Three packages to understand the whole system. That's actually pretty clean for 230K stars.\n\nSAM: The architecture *is* clean. That's the takeaway. React's codebase is large, but the separation of concerns is excellent. Reconciler, renderer, public API \u2014 each has a clear job. And that clarity is what's allowed it to evolve so dramatically over the past decade while remaining the dominant UI library.\n\nALEX: Brilliant breakdown, Sam. Thanks for guiding us through. That's all for this episode of RepoLM!\n\nSAM: Happy rendering, everyone.\n\n*(Outro music fades in and out)*",
  "slides": "# React\n## The Library That Changed Frontend Forever\n\n*From facebook/react \u2014 230K+ stars on GitHub*\n---\n# What is React?\n\n- A **JavaScript library** for building user interfaces\n- Created by Jordan Walke at Meta (Facebook) in 2013\n- Core idea: **declarative, component-based UI**\n- Not a framework \u2014 focused purely on the view layer\n\n> \"Describe what your UI should look like, and React makes it happen.\"\n---\n# The Declarative Model\n\n```jsx\n// Declarative (React)\nfunction Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}\n\n// Imperative (vanilla JS)\ndocument.getElementById('greeting').textContent = 'Hello, ' + name;\n```\n\n**Tell React what you want**, not how to get there.\nReact figures out the DOM updates for you.\n---\n# Components: The Building Blocks\n\n```jsx\nfunction UserCard({ user }) {\n  return (\n    <div className=\"card\">\n      <img src={user.avatar} />\n      <h2>{user.name}</h2>\n      <p>{user.bio}</p>\n    </div>\n  );\n}\n\nfunction UserList({ users }) {\n  return users.map(u => <UserCard key={u.id} user={u} />);\n}\n```\n\nEverything is a **composable, reusable component**.\n---\n# JSX\n\nHTML-like syntax that compiles to JavaScript:\n\n```jsx\n// What you write\nconst el = <h1 className=\"title\">Hello</h1>;\n\n// What it compiles to\nconst el = React.createElement('h1', { className: 'title' }, 'Hello');\n```\n\n- Not required, but dramatically improves readability\n- Full power of JavaScript inside `{}`\n- Looks like HTML, runs like JS\n---\n# Virtual DOM & Reconciliation\n\nReact's performance engine:\n\n```\nState Change\n    |\n    v\nRender new Virtual DOM tree\n    |\n    v\nDiff against previous tree\n    |\n    v\nApply minimal DOM mutations\n```\n\n- Virtual DOM = lightweight JS representation of the UI\n- Reconciliation algorithm diffs old vs new\n- Only **changed nodes** get updated in the real DOM\n---\n# The Fiber Architecture\n\nReact 16's complete rewrite of the rendering engine:\n\n- Each component becomes a **fiber** (unit of work)\n- Rendering is **interruptible** \u2014 can pause and resume\n- Updates have **priorities** (user input > background updates)\n- Enables **concurrent rendering**\n\nKey files:\n- `ReactFiber.js` \u2014 Fiber data structure\n- `ReactFiberWorkLoop.js` \u2014 The main render loop\n- `ReactFiberBeginWork.js` \u2014 Component rendering\n- `ReactFiberCompleteWork.js` \u2014 DOM node creation\n---\n# Hooks\n\nFunction components with superpowers (React 16.8+):\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  useEffect(() => {\n    document.title = `Count: ${count}`;\n  }, [count]);\n  \n  return (\n    <button onClick={() => setCount(c => c + 1)}>\n      Clicked {count} times\n    </button>\n  );\n}\n```\n\n`useState`, `useEffect`, `useContext`, `useRef`, `useMemo`...\n---\n# How Hooks Work Internally\n\n- Each fiber has a **linked list** of hook states\n- React walks the list **in order** on each render\n- That's why hooks can't be inside conditionals!\n\n```\nFiber: <Counter />\n  Hook 0: useState(0)     -> count = 5\n  Hook 1: useEffect(fn)   -> deps = [5]\n  Hook 2: useCallback(fn) -> cached fn\n```\n\nImplemented in `ReactFiberHooks.js` \u2014 one of React's most complex files.\n---\n# The Renderer Architecture\n\nReconciler is **platform-agnostic**:\n\n- **react-dom** -> Browser DOM\n- **react-native** -> iOS / Android\n- **react-three-fiber** -> WebGL / Three.js\n- **Ink** -> Terminal UI\n- **react-pdf** -> PDF documents\n\nThe reconciler calls abstract methods (\"create instance\", \"append child\").\nEach renderer implements them for its platform.\n---\n# Concurrent React\n\nBuilt on Fiber's interruptible rendering:\n\n```jsx\nfunction SearchResults({ query }) {\n  const [isPending, startTransition] = useTransition();\n  \n  function handleChange(e) {\n    // High priority: update input\n    setInput(e.target.value);\n    // Low priority: update results\n    startTransition(() => setQuery(e.target.value));\n  }\n}\n```\n\nUser input stays responsive even during heavy rendering.\n---\n# Suspense\n\nDeclarative loading states:\n\n```jsx\nfunction ProfilePage() {\n  return (\n    <Suspense fallback={<Spinner />}>\n      <ProfileDetails />\n      <Suspense fallback={<PostsSkeleton />}>\n        <ProfilePosts />\n      </Suspense>\n    </Suspense>\n  );\n}\n```\n\nNo more `isLoading` booleans everywhere.\nComponents \"suspend\" until their data is ready.\n---\n# Server Components\n\nThe newest evolution \u2014 components that run on the server:\n\n```jsx\n// Server Component (zero client JS)\nasync function BlogPost({ id }) {\n  const post = await db.posts.findById(id);\n  return <article>{post.content}</article>;\n}\n```\n\n- Direct database access\n- Zero bundle size impact\n- Seamless integration with client components\n- Progressive HTML streaming\n---\n# Key Takeaways\n\n1. **Declarative** \u2014 describe what, not how\n2. **Components** \u2014 composable, reusable UI units\n3. **Virtual DOM** \u2014 efficient diffing and minimal DOM updates\n4. **Fiber** \u2014 interruptible, prioritized rendering\n5. **Hooks** \u2014 simple, powerful state and effects\n6. **Platform-agnostic** \u2014 reconciler separate from renderers\n7. **Always evolving** \u2014 concurrent features, server components\n\n*React didn't just build a library \u2014 it built a mental model for UI.*\n---\n# Explore the Code\n\nStart here:\n\n- `packages/react/` \u2014 Public API (thin!)\n- `packages/react-reconciler/` \u2014 The brain\n- `packages/react-dom/` \u2014 Browser renderer\n\n```bash\ngit clone https://github.com/facebook/react.git\ncd react\nyarn install\nyarn build\n```\n\n**Three packages to understand the whole system.**"
}