{
  "slug": "fastapi",
  "repo": "tiangolo/fastapi",
  "name": "FastAPI",
  "description": "The modern Python web framework. Learn async, type hints, automatic docs, and dependency injection.",
  "tags": [
    "Python",
    "Async",
    "REST API"
  ],
  "depth": "high-level",
  "expertise": "amateur",
  "overview": "Let's dive into FastAPI, one of the fastest-growing Python web frameworks and a masterclass in modern API design.\n\n### 1. The Big Picture: Speed Through Standards\n\nFastAPI was created by Sebasti\u00e1n Ram\u00edrez with a clear mission: build the fastest, most developer-friendly Python API framework by leveraging modern Python features \u2014 specifically **type hints** and **async/await**. What makes FastAPI special isn't any single innovation, but how it brilliantly combines existing standards into a cohesive whole.\n\nThe framework is built on three pillars:\n- **Starlette** \u2014 A high-performance ASGI framework that handles HTTP, WebSockets, and middleware\n- **Pydantic** \u2014 A data validation library that uses Python type hints to validate and serialize data\n- **OpenAPI** \u2014 The industry standard for describing REST APIs\n\nFastAPI's genius is that by writing normal Python with type hints, you automatically get validation, serialization, and API documentation \u2014 with zero extra work.\n\n### 2. Type Hints as the Single Source of Truth\n\nThis is FastAPI's defining architectural decision. In most frameworks, you write your route handler, then separately write validation logic, then separately write documentation. In FastAPI, your type annotations do all three:\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    name: str\n    price: float\n    is_offer: bool = False\n\n@app.post(\"/items/\")\nasync def create_item(item: Item):\n    return {\"item_name\": item.name, \"price_with_tax\": item.price * 1.1}\n```\n\nFrom this single function signature, FastAPI:\n1. **Validates** incoming JSON against the `Item` schema (returns 422 with clear errors if invalid)\n2. **Parses** the validated data into a Python object with autocomplete support\n3. **Documents** the endpoint in auto-generated OpenAPI/Swagger docs\n4. **Serializes** the response to JSON\n\nThere's no duplication. The type hints are the contract.\n\n### 3. ASGI and Async-First Design\n\nFastAPI is built on ASGI (Asynchronous Server Gateway Interface), the successor to Python's WSGI standard. While Flask and Django were built for synchronous, one-request-at-a-time processing, FastAPI natively supports async/await:\n\n```python\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: int):\n    user = await database.fetch_one(\n        \"SELECT * FROM users WHERE id = :id\", {\"id\": user_id}\n    )\n    return user\n```\n\nThe `async` keyword isn't just decoration \u2014 it means this handler can yield control while waiting for the database, allowing the server to handle other requests concurrently. This is how FastAPI achieves performance comparable to Node.js and Go for I/O-bound workloads.\n\nUnder the hood, Starlette provides the ASGI application class. FastAPI extends Starlette's routing and middleware with its type-driven features.\n\n### 4. Dependency Injection: The Power Feature\n\nFastAPI's dependency injection system is one of its most powerful and underappreciated features. Dependencies are declared using `Depends()`:\n\n```python\nfrom fastapi import Depends, HTTPException\n\nasync def get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\nasync def get_current_user(\n    token: str = Header(...),\n    db: Session = Depends(get_db)\n):\n    user = await db.query(User).filter(User.token == token).first()\n    if not user:\n        raise HTTPException(status_code=401)\n    return user\n\n@app.get(\"/items/\")\nasync def read_items(user: User = Depends(get_current_user)):\n    return await get_user_items(user.id)\n```\n\nDependencies can depend on other dependencies, forming a graph that FastAPI resolves automatically. This enables database session management, authentication, configuration injection, and caching \u2014 all reusable and testable.\n\nThe dependency graph is resolved at startup time, so there's no runtime overhead for figuring out what depends on what.\n\n### 5. Automatic API Documentation\n\nOne of FastAPI's most impressive features is automatic, interactive API documentation. By default, every FastAPI app exposes:\n\n- **Swagger UI** at `/docs` \u2014 Interactive playground where you can test every endpoint\n- **ReDoc** at `/redoc` \u2014 Beautiful, readable API reference\n\nThese aren't generated from comments or separate spec files. They're generated directly from your route signatures, type hints, and Pydantic models. Your code IS your documentation.\n\n### 6. Request Handling Pipeline\n\nWhen a request arrives, FastAPI processes it through several layers:\n\n1. **Middleware** \u2014 CORS, authentication, logging (inherited from Starlette)\n2. **Routing** \u2014 Match the URL path and HTTP method to a handler\n3. **Dependency resolution** \u2014 Resolve all `Depends()` in the handler's signature\n4. **Parameter extraction** \u2014 Pull data from path, query, headers, cookies, body\n5. **Validation** \u2014 Pydantic validates all extracted parameters\n6. **Handler execution** \u2014 Your async function runs\n7. **Response serialization** \u2014 Output validated against `response_model`\n8. **Response** \u2014 JSON response sent to client\n\n### 7. The Router System\n\nLike Express and Flask, FastAPI supports modular routing through `APIRouter`:\n\n```python\n# routes/users.py\nfrom fastapi import APIRouter\nrouter = APIRouter(prefix=\"/users\", tags=[\"users\"])\n\n@router.get(\"/\")\nasync def list_users(): ...\n\n@router.get(\"/{user_id}\")\nasync def get_user(user_id: int): ...\n\n# main.py\nfrom routes.users import router as users_router\napp.include_router(users_router)\n```\n\nRouters support their own dependencies, middleware, and prefix configuration.\n\n### 8. Performance\n\nFastAPI is one of the fastest Python web frameworks available. This performance comes from:\n- **ASGI** \u2014 Non-blocking I/O handling\n- **Uvicorn** \u2014 Lightning-fast ASGI server built on uvloop\n- **Starlette** \u2014 Minimal overhead in the HTTP layer\n- **Pydantic v2** \u2014 Rust-powered validation (using `pydantic-core`)\n\n### Summary\n\nFastAPI's architecture is a masterclass in leveraging Python's type system:\n\n- **Type hints are the contract** \u2014 One annotation drives validation, docs, and serialization\n- **Async-first** \u2014 Built on ASGI for high-concurrency performance\n- **Dependency injection** \u2014 Clean, composable, testable architecture\n- **Standards-based** \u2014 OpenAPI, JSON Schema, OAuth2 built in\n- **Zero boilerplate** \u2014 Write less code, get more functionality\n\nFastAPI proved that Python can be both developer-friendly and fast.",
  "podcast": "*(Intro music \u2014 clean, energetic beat)*\n\nALEX: Hey everyone, welcome to RepoLM! I'm Alex.\n\nSAM: And I'm Sam. Today we're looking at a framework that's been on an absolute tear through the Python ecosystem. It went from zero to one of the most-starred Python repos on GitHub in just a few years.\n\nALEX: FastAPI. Created by Sebasti\u00e1n Ram\u00edrez. And I have to say, after digging through this codebase, I understand the hype. This framework is *elegant*.\n\nSAM: It really is. So let's set the stage. Before FastAPI, if you wanted to build an API in Python, your main options were Flask and Django REST Framework. Both great, but both designed in a pre-async, pre-type-hints world.\n\nALEX: Right. Flask was synchronous. Django REST Framework had serializers that were basically duplicating your models. And neither gave you automatic API documentation without extra tooling.\n\nSAM: FastAPI looked at all those pain points and said: \"What if we just used Python's type hints to solve all of them at once?\" And that's the core insight. Your type annotations aren't just for your IDE \u2014 they drive validation, serialization, and documentation.\n\nALEX: Let me give a concrete example for our listeners. In Flask, if you want to accept a JSON body with specific fields, you'd do something like: parse the request JSON manually, validate each field, handle errors, convert types. Maybe use Marshmallow or WTForms for validation. It's a lot of plumbing.\n\nSAM: In FastAPI, you write a Pydantic model with type annotations, put it as a parameter in your function, and you're done. FastAPI handles everything \u2014 parsing, validation, error messages, documentation. If someone sends invalid data, they get a clear 422 response explaining exactly what's wrong.\n\nALEX: It's almost too clean. When I first saw it, I thought \"there must be a catch.\" But looking at the code, it's genuinely well-engineered. It's not magic \u2014 it's clever use of Python's introspection capabilities.\n\nSAM: Exactly. And let's talk about the foundation it's built on. FastAPI doesn't reinvent the wheel \u2014 it's built on Starlette for the web layer and Pydantic for data handling. Starlette is this beautifully minimal ASGI framework. It handles all the HTTP plumbing \u2014 routing, middleware, WebSockets, static files. It's fast and well-tested.\n\nALEX: And ASGI is the key to FastAPI's async story, right?\n\nSAM: Right. ASGI is to async Python what WSGI was to synchronous Python. It's the standard interface between your application and the server. Starlette implements ASGI, and FastAPI extends Starlette. When you define an `async def` route handler, it runs on the event loop. When you `await` a database query or an HTTP call, the server can handle other requests in the meantime.\n\nALEX: That's how FastAPI gets Node.js-like performance in Python.\n\nSAM: For I/O-bound workloads, yes. And it's worth noting that FastAPI is smart about this \u2014 if you define a regular `def` handler without async, it runs it in a thread pool so it doesn't block the event loop. So you can mix sync and async code freely.\n\nALEX: That's a really nice touch. Now, the feature that blew me away was the dependency injection system. Can you break that down?\n\nSAM: Oh, this is the killer feature that nobody talks about enough. In most frameworks, if you need something like the current user or a database session in your handler, you either use middleware that attaches it to the request object, or you use some global context variable.\n\nALEX: Like Flask's `g` object.\n\nSAM: Exactly. FastAPI takes a different approach. You declare dependencies as function parameters using `Depends()`. A dependency is just a function \u2014 it can be sync or async, it can use `yield` for cleanup, and it can have its own dependencies.\n\nALEX: Dependencies all the way down.\n\nSAM: (Laughs) Right. And FastAPI builds a dependency graph and resolves it for each request. Database session, current user, rate limiter, feature flags \u2014 they're all just dependencies. What's beautiful is that this makes everything explicit and testable. In your tests, you can override any dependency with a mock.\n\nALEX: I saw that in the docs \u2014 `app.dependency_overrides`. That's so much cleaner than monkeypatching.\n\nSAM: It is. And the dependency graph is analyzed at startup time, so there's no runtime overhead for resolution. If you have a circular dependency or a missing dependency, you find out when the app starts, not when a request hits.\n\nALEX: Let's talk about the automatic documentation. I went to `/docs` on a FastAPI app and my jaw dropped. Full Swagger UI, every endpoint documented, request/response schemas, you can even try endpoints right there.\n\nSAM: And you wrote zero documentation code. It's all derived from your type hints. Your Pydantic models become JSON Schemas. Your path parameters, query parameters, headers \u2014 all documented with types and validation constraints. Even your docstrings become endpoint descriptions.\n\nALEX: The dream of \"self-documenting code\" actually realized.\n\nSAM: It's close! And there's also `/redoc` for a more readable reference-style documentation. Both are generated from the same OpenAPI spec that FastAPI builds automatically.\n\nALEX: OK so performance. FastAPI claims to be one of the fastest Python frameworks. What's behind that?\n\nSAM: It's a combination. First, ASGI with Uvicorn \u2014 which uses uvloop, a Cython-based event loop that's significantly faster than the default asyncio loop. Second, Starlette is minimal \u2014 very little overhead between the request and your handler. Third, Pydantic v2 uses pydantic-core, which is written in Rust. So your data validation is happening at near-native speeds.\n\nALEX: Rust-powered validation in a Python framework. What a time to be alive.\n\nSAM: (Laughs) It really is. And the benchmarks show it. For pure API workloads, FastAPI is in the same ballpark as Node.js Express and Go Gin, which is remarkable for Python.\n\nALEX: Alright, to wrap up \u2014 what's your summary of FastAPI's architecture?\n\nSAM: FastAPI is a masterclass in \"make the right thing easy.\" By betting on type hints as the single source of truth, it eliminated an entire category of boilerplate. By building on Starlette and ASGI, it got async performance for free. By using Pydantic, it got world-class validation. And by adding dependency injection, it made complex apps composable and testable. Every piece reinforces every other piece. It's one of the most cohesive framework designs I've seen.\n\nALEX: It's like the framework equivalent of \"and then everything just clicked.\" Brilliant stuff. That's all for today's episode!\n\nSAM: Thanks for listening, everyone. Go build something fast.\n\n*(Outro music fades)*",
  "slides": "# FastAPI\n## Modern, Fast, Python Web Framework\n\n*High performance, easy to learn, fast to code, ready for production*\n---\n# What is FastAPI?\n\n- **Python web framework** for building APIs\n- Created by Sebasti\u00e1n Ram\u00edrez in 2018\n- One of the **fastest-growing** Python projects ever\n- Built on **type hints** \u2014 your annotations drive everything\n\n> \"FastAPI is to Python APIs what React was to frontend development.\"\n---\n# The Three Pillars\n\nFastAPI combines three powerful foundations:\n\n- **Starlette** \u2014 ASGI framework (HTTP, WebSockets, middleware)\n- **Pydantic** \u2014 Data validation via type hints\n- **OpenAPI** \u2014 Automatic API documentation\n\nFastAPI is the **glue** that makes them work seamlessly together.\n---\n# Hello World\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n```\n\n```bash\npip install fastapi uvicorn\nuvicorn main:app --reload\n```\n\nVisit `http://localhost:8000/docs` \u2014 **automatic Swagger UI!**\n---\n# Type Hints = Everything\n\n```python\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    price: float\n    is_offer: bool = False\n\n@app.post(\"/items/\")\nasync def create_item(item: Item):\n    return {\"name\": item.name, \"total\": item.price * 1.1}\n```\n\nFrom this one signature, FastAPI:\n- **Validates** incoming JSON\n- **Parses** into a typed Python object\n- **Documents** in Swagger/ReDoc\n- **Serializes** the response\n---\n# Async-First Design\n\nBuilt on ASGI for high-concurrency performance:\n\n```python\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: int):\n    user = await database.fetch_one(\n        \"SELECT * FROM users WHERE id = :id\", \n        {\"id\": user_id}\n    )\n    return user\n```\n\n- `async/await` for I/O operations\n- Non-blocking \u2014 handles thousands of concurrent requests\n- **Performance comparable to Node.js and Go**\n---\n# Dependency Injection\n\nFastAPI's killer feature:\n\n```python\nasync def get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\nasync def get_current_user(\n    token: str = Header(...),\n    db = Depends(get_db)\n):\n    return await db.query(User).filter_by(token=token).first()\n\n@app.get(\"/items/\")\nasync def read_items(user = Depends(get_current_user)):\n    return await get_user_items(user.id)\n```\n\nDependencies can depend on dependencies. Graph resolved at startup.\n---\n# Automatic API Documentation\n\nZero-config, always up-to-date:\n\n- **Swagger UI** at `/docs` \u2014 interactive API playground\n- **ReDoc** at `/redoc` \u2014 beautiful reference docs\n- Generated from your **type hints and models**\n\nYour code **IS** your documentation.\n---\n# Request Pipeline\n\n```\nRequest arrives\n    |\n    v\nMiddleware (CORS, auth, logging)\n    |\n    v\nRouting (match URL + method)\n    |\n    v\nDependency Resolution\n    |\n    v\nParameter Extraction (path, query, body, headers)\n    |\n    v\nPydantic Validation\n    |\n    v\nHandler Execution (your async function)\n    |\n    v\nResponse Serialization -> JSON Response\n```\n---\n# Modular Routing\n\n```python\n# routes/users.py\nfrom fastapi import APIRouter\nrouter = APIRouter(prefix=\"/users\", tags=[\"users\"])\n\n@router.get(\"/\")\nasync def list_users(): ...\n\n@router.get(\"/{user_id}\")\nasync def get_user(user_id: int): ...\n\n# main.py\nfrom routes.users import router\napp.include_router(router)\n```\n\nRouters support their own dependencies, middleware, and prefixes.\n---\n# WebSockets\n\nNative WebSocket support via Starlette:\n\n```python\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(\n    websocket: WebSocket, \n    client_id: str\n):\n    await websocket.accept()\n    while True:\n        data = await websocket.receive_text()\n        await websocket.send_text(f\"Echo: {data}\")\n```\n\nSame dependency injection, same type safety.\n---\n# Performance Stack\n\n- **Uvicorn** \u2014 ASGI server with uvloop (Cython event loop)\n- **Starlette** \u2014 Minimal HTTP overhead\n- **Pydantic v2** \u2014 Rust-powered validation\n- **ASGI** \u2014 Non-blocking I/O\n\nBenchmark results (requests/sec):\n- FastAPI: ~15,000\n- Flask: ~3,000\n- Django: ~2,500\n\n*For I/O-bound API workloads*\n---\n# Testing\n\n```python\nfrom fastapi.testclient import TestClient\nclient = TestClient(app)\n\ndef test_create_item():\n    response = client.post(\"/items/\", json={\n        \"name\": \"Widget\",\n        \"price\": 9.99\n    })\n    assert response.status_code == 200\n    assert response.json()[\"name\"] == \"Widget\"\n\n# Override dependencies for tests\napp.dependency_overrides[get_db] = mock_db\n```\n\nDependency overrides make testing **clean and isolated**.\n---\n# Key Takeaways\n\n1. **Type hints are the single source of truth**\n2. **Async-first** for Node.js-level performance\n3. **Dependency injection** makes apps composable and testable\n4. **Automatic docs** \u2014 Swagger UI and ReDoc for free\n5. **Standards-based** \u2014 OpenAPI, JSON Schema, OAuth2\n6. **Pydantic v2** \u2014 Rust-powered validation\n\n### FastAPI proved Python can be both developer-friendly AND fast.\n---\n# Get Started\n\n```bash\npip install fastapi[standard]\n```\n\n```python\nfrom fastapi import FastAPI\napp = FastAPI()\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n```\n\n```bash\nfastapi dev main.py\n# Docs at http://localhost:8000/docs\n```\n\n**Type it. Run it. Document it. Ship it.**"
}